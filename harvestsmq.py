#! /usr/bin/python
import serial
import json
import linecache
import sys
import paho.mqtt.client as mqtt
from time import time,sleep,ctime, gmtime, strftime
import ConfigParser
import ssl
import os
from array import *
import logging
import logging.handlers
import argparse
import re
# Defaults
LOG_FILENAME = "/var/log/weathersys/harvestsmq.log"
LOG_LEVEL = logging.INFO  # Could be e.g. "DEBUG" or "WARNING"

# Define and parse command line arguments
parser = argparse.ArgumentParser(description="SMTQuad data poller")
parser.add_argument("-l", "--log", help="file to write log to (default '" + LOG_FILENAME + "')")

# If the log file is specified on the command line then override the default
args = parser.parse_args()
if args.log:
        LOG_FILENAME = args.log

# Configure logging to log to a file, making a new file at midnight and keeping the last 3 day's data
# Give the logger a unique name (good practice)
logger = logging.getLogger(__name__)
# Set the log level to LOG_LEVEL
logger.setLevel(LOG_LEVEL)
# Make a handler that writes to a file, making a new file at midnight and keeping 3 backups
handler = logging.handlers.TimedRotatingFileHandler(LOG_FILENAME, when="midnight", backupCount=3)
# Format each log message like this
formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')
# Attach the formatter to the handler
handler.setFormatter(formatter)
# Attach the handler to the logger
logger.addHandler(handler)

def s8(value):
    return -(value & 0x80) | (value & 0x7f)

# Make a class we can use to capture stdout and sterr in the log
class MyLogger(object):
        def __init__(self, logger, level):
                """Needs a logger and a logger level."""
                self.logger = logger
                self.level = level

        def write(self, message):
                # Only log if there is a message (not just a new line)
                if message.rstrip() != "":
                        self.logger.log(self.level, message.rstrip())

# Replace stdout with logging to file at INFO level
sys.stdout = MyLogger(logger, logging.INFO)
# Replace stderr with logging to file at ERROR level
sys.stderr = MyLogger(logger, logging.ERROR)


connected=False

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    global connected
    print("Connected with result code "+str(rc))
    if rc != 0:
        print("Unexpected disconnection. Reconnecting...")
        mqttc.reconnect()
	connected=False
    else :
        print "Connected successfully"
	conected=True

# The callback for when a PUBLISH message is received from the server.
def on_publish(client, userdata, mid):
        print "Publish Mid: "+ str(mid)

def on_disconnect(client, userdata, rc):
    global connected
    if rc != 0:
        print("Unexpected disconnection.")
	mqttc.reconnect()
	connected=False

def check_connection():
    if (connected==False):
        print("Reconnecing\n\r")
        mqttc.connect(config.get("harvester", "server"), config.get("harvester", "port"), 60)


def PrintException():
    exc_type, exc_obj, tb = sys.exc_info()
    f = tb.tb_frame
    lineno = tb.tb_lineno
    filename = f.f_code.co_filename
    linecache.checkcache(filename)
    line = linecache.getline(filename, lineno, f.f_globals)
    print 'EXCEPTION IN ({}, LINE {} "{}"): {}'.format(filename, lineno, line.strip(), exc_obj)

def jsonlog(d):
	print (d)

def strlog(s):
	print (s)


def crc(msg, div, code='000'):
    """Cyclic Redundancy Check
    Generates an error detecting code based on an inputted message
    and divisor in the form of a polynomial representation.
    Arguments:
        msg: The input message of which to generate the output code.
        div: The divisor in polynomial form. For example, if the polynomial
            of x^3 + x + 1 is given, this should be represented as '1011' in
            the div argument.
        code: This is an option argument where a previously generated code may
            be passed in. This can be used to check validity. If the inputted
            code produces an outputted code of all zeros, then the message has
            no errors.
    Returns:
        An error-detecting code generated by the message and the given divisor.
    """
    # Append the code to the message. If no code is given, default to '000'
    msg = msg + code

    # Convert msg and div into list form for easier handling
    msg = list(msg)
    div = list(div)

    # Loop over every message bit (minus the appended code)
    for i in range(len(msg)-len(code)):
        # If that messsage bit is 1, perform modulo 2 multiplication
        if msg[i] == '1':
            for j in range(len(div)):
                # Perform modulo 2 multiplication on each index of the divisor
                msg[i+j] = str((int(msg[i+j])+int(div[j]))%2)

    # Output the last error-checking code portion of the message generated
    return ''.join(msg[-len(code):])


cfgname=os.path.splitext(__file__)[0]+".cfg"

print "Reading default config file " + cfgname

config = ConfigParser.ConfigParser({'baud': '38400', 'port': '1883', 'defaulttopic':'sensors/'})
config.read(cfgname)


ser=serial.Serial(config.get("harvester", "serial"), config.get("harvester", "baud"), timeout=20)
print(ser.name, ' opened.\n')
mqttc = mqtt.Client(config.get("harvester", "clientname"))
mqttc.on_connect = on_connect
mqttc.on_disconnect = on_disconnect
mqttc.on_publish = on_publish

# the server to publish to, and corresponding port
# the server to publish to, and corresponding port
mqttc.tls_set('/usr/local/harvest/cert/ca.crt', certfile='/usr/local/harvest/cert/wthr.crt', keyfile='/usr/local/harvest/cert/wthr.key', cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1, ciphers=None)
mqttc.tls_insecure_set(True)
mqttc.username_pw_set(config.get("harvester", "user"), password=config.get("harvester", "pass"))


mqttc.connect(config.get("harvester", "server"), config.get("harvester", "port"), 60)

default_topic=config.get("harvester", "defaulttopic")

run=True
jdata = None
lsec=0

cntsec=time()+5;
trgsec=cntsec+20;
dhtsec=cntsec+30;

while run:
	lsec=time()
# Query collection card

	if (lsec>cntsec):	# poll counter
		cntsec=cntsec+60
		ser.write("?G\r\n")
        elif (lsec>trgsec):     # start DHT22
                trgsec=trgsec+60
                ser.write("*s\r\n")
	elif (lsec>dhtsec):	# poll DHT22
		dhtsec=dhtsec+60
		ser.write("*r\r\n")

	line=ser.readline().strip()
# Parse input data
	crcval=1	#just set other than 1 to trap errors later
	if len(line)>0:
		splitdta=re.findall("^#(\d{2})Ch:(\d{2})-(\w*)=(\S*) !(\w{2})",line)
		print (line)
		if (len(splitdta)==1): #Looks good
			splitdta=splitdta[0]
#			print(crc(splitdta[4],'1001101'))
#CRC not implemented
			if (len(splitdta)==5):
				try:
					if (splitdta[2]=='SMT'):
						type='smt'
						chanel=int(splitdta[1])
						val=splitdta[3]
						crcval=0
						print type, val, crcval

					elif (splitdta[2]=='DHT'):
						type="dht"
						chanel=int(splitdta[1])
						crcval=0
						vals=array('B')
						matches=re.findall("^T:([0-9,a-f]{2}).([0-9,a-f]{2}).H:([0-9,a-f]{2}).([0-9,a-f]{2})",splitdta[3])[0]						
	                                        for n in matches:
	                                                curbyte=int(n,16)&0xff
							vals.append(curbyte)
						if (vals[0]&0x80): #Negative
							hexval=((vals[0]&0x7f)<<8)+vals[1] # Reasemble
							intval=int(hexval/10)
							decval=hexval%10						
							tmpval=(intval+(decval/10.0))*(-1.0)
						else: #Plus
	                                                hexval=((vals[0]&0x7f)<<8)+vals[1] # Reasemble
	                                                intval=int(hexval/10)
	                                                decval=hexval%10
	                                                tmpval=intval+(decval/10.0)

#						print (hexval, intval, decval,tmpval)
						hexval=((vals[2]&0x7f)<<8)+vals[3] # Reasemble
						intval=int(hexval/10)
						decval=hexval%10
						humval=s8(intval)+(decval/10.0)
#						print (hexval, intval, decval, humval)
	
	                                        print("type=",type, " tmp=",tmpval, " hum=", humval, " crc=",crcval)
					
					elif (splitdta[2][0:2]=='AD'):
						type='adc'
						channel=chanel=int(splitdta[1])
						adch=int(splitdta[2][2:4])
                                                val=splitdta[3]
                                                crcval=0
                                                print type, channel,val, crcval


					else:
						type="err"
						print "Err2: ", line 
				except ValueError:
					PrintException()
		else:
			print "Err1: ", line

		
		if (crcval==0):	#Valid values
			print((type+str(chanel)))		
			if (config.has_section(type+str(chanel))):
				mq_name=config.get(type+str(chanel), 'name')
				mq_topic=config.get(type+str(chanel), 'topic')
				ctime=strftime("%Y-%m-%d %H:%M:%S", gmtime())

				if (type=='cnt'):
					print( ctime, " - ", mq_name, ", ", type, ", ", cntval)
					try:
						check_connection()
						mqttc.publish(mq_topic+'/name', mq_name,qos=1)
						mqttc.publish(mq_topic+'/energy', cntval*50,qos=1) # 20 pulses / kWh -> 50W / pulse
					except ValueError:
						PrintException()
					except:
						PrintException()
				elif (type=='dht'):
                                        print ctime, " - ", mq_name, ", ", type, ", ", tmpval, ", ",humval
                                        try:
						check_connection()
                                                mqttc.publish(mq_topic+'/name', mq_name, qos=1)
                                                mqttc.publish(mq_topic+'/temperature', float(tmpval),qos=1)
                                                mqttc.publish(mq_topic+'/humidity', float(humval),qos=1)
                                        except ValueError:
                                                PrintException()
					except:
						PrintException()


			else:
				mq_name='Unknown'
				mq_topic=default_topic+str(chanel)
        try:
                mqttc.loop(2)
        except:
                PrintException()

	sleep(1)

